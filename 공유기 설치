#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
bool cmp(int a, int b) {
	return a < b;
}
int main(void) {

	int N, R;
	cin >> N >> R;
	int arr[200001];
	for (int i = 0; i < N; ++i) {
		cin >> arr[i];
	}
	sort(arr, arr + N , cmp);

	int left = 1;
	int right = arr[N-1]- arr[0];
	int ans = 0;
	int dist = 0;
	while (left <= right) {
		int cur = arr[0];
		int mid = (left + right) / 2;//간격
		int cnt = 1;
		for (int i = 1; i < N; ++i) {
			dist = arr[i] - cur;
			if(mid <= dist){
				cnt++;
				cur = arr[i];
			}
		}
		if (cnt >= R) {//공유기의 개수가 r보다 크다
			ans = mid;
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}

	}
	cout << ans << endl;
	return 0;
}
이분탐색으로 최소가능 간격과 최대 가능 간격을 구해서 공유기 숫자에 따라 간격을 이동시켜주고 
최소간격이 최대 간격보다 커지면 종료하도록 구성하면 최대간격을 구할 수 있다. 

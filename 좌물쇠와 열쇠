https://programmers.co.kr/learn/courses/30/lessons/60059

#include <string>
#include <vector>

using namespace std;
void match(int r, int c, int arr[58][58], vector<vector<int>> key, int rot) {
    int n = key.size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (rot == 0)
                arr[r + i][c + j] += key[i][j];
            else if (rot == 1)
                arr[r + i][c + j] += key[j][n - 1 - i];
            else if (rot == 2)
                arr[r + i][c + j] += key[n - 1 - i][n - 1 - j];
            else
                arr[r + i][c + j] += key[n - 1 - j][i];
        }
    }

}
bool check(int arr[58][58], int offset, int n){
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (arr[offset + i][offset + j] != 1) {
                return false;
            }
        }
    }
    return true;
}

bool solution(vector<vector<int>> key, vector<vector<int>> lock) {
    int offset = key.size() - 1;
    
    for (int r = 0; r < offset + lock.size(); r++) {
        for (int c = 0; c < offset + lock.size(); c++) {
            for (int rot = 0; rot < 4; rot++) {
                int arr[58][58] = { 0 };
                for (int i = 0; i < lock.size(); i++) {
                    for (int j = 0; j < lock.size(); j++) {
                        arr[offset + i][offset + j] = lock[i][j];
                    }
                }
                match(r, c, arr, key, rot);
                if (check(arr, offset, lock.size())){
                    return true;
                }
            }
        }
    }
    return false;
}

좌물쇠에 열쇠를 끼워넣는 문제인데, 너무 어려워서 며칠을 고민하다가 결국 유투브를 통해서 배웠다.
https://youtu.be/JpiRVpa03VA

1.완전 탐색으로 푸는 문제인데 큰 배열을 하나 만들고 자물쇠를 배열을 중간에 두고 열쇠 배열을 한칸씩움직이면서 비교해야한다.
->우선 1번을 생각해내는게 어려웠다. 진짜 어려웠다... 완탐맞냐,,,?
2. 대신 배열을 다루기에는 정말 더 없이 좋은 문제처럼 느껴진다. 이 문제는 자주 풀어 봐야겠다는 생각이 든다.

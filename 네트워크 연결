https://www.acmicpc.net/problem/1922
#include <algorithm>
#include <iostream>
#include <queue>
using namespace std;
int parent[1001];

struct city {
	int from, to, weight;
};

struct cmp {
	bool operator()(city a, city b) {
		return a.weight > b.weight;
	}
};
int find_parent(int x) {
	if (x == parent[x])
		return x;
	else 
		return parent[x]=find_parent(parent[x]);
}
void union_parent(int a, int b) {
	a = find_parent(a);
	b = find_parent(b);
	if (a < b)
		parent[b] = a;
	else
		parent[a] = b;
}

int main() {
	int sum = 0;
	priority_queue<city, vector<city>, cmp> pq;
	int n, edge;
	cin >> n >> edge;
	for (int i = 0; i < n; i++) {
		parent[i] = i;
	}
	for (int i = 0; i < edge; ++i) {
		city c;
		cin >> c.from >> c.to >> c.weight;
		pq.push(c);
	}
	while (!pq.empty()) {
		city a;
		a = pq.top(); pq.pop();
		if (find_parent(a.from)!=find_parent(a.to)) {
			union_parent(a.from, a.to);
			sum += a.weight;
		}
	}
	cout << sum;
	return 0;
}
/*6
9
2 3 2
4 5 3
1 3 4
3 4 6
1 2 5
2 4 7
5 6 8
4 6 8
3 5 11
*/
네트워크 연결문제인데, 크루스칼을 고대로 구현하면 된다.

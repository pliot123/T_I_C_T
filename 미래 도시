#include <iostream>
#include <vector>
#include <algorithm>
#define MAX 999;
using namespace std;
int map[100][100];
int main() {
    int n, m;//회사 갯수와 간선
    cin >> n >> m;
    int a, b;

    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++)
            if(i==j)
                map[i][i] = 0;
            else
                map[i][j] = MAX;
            
    }
    
    for (int i = 1; i <= m; i++){
        cin >> a >> b;
        map[a][b] = 1;
        map[b][a] = 1;
    }

    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
            }
        }
    }

    cout << endl << endl;


    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << map[i][j] << ' ';
        }
        cout << endl;
    }



    int q, w;//x k 
    cin >> q >> w;

    cout << map[1][w] +map[w][q];
    

    return 0;
}
플로이드 워셜 알고리즘을 이용한 최단거리를 구하는 문제였다. 
'플로이드 워셜' 알고리즘을 구현하는 것은 그리 어렵지 않다.

    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
            }
        }
    }
워셜 알고리즘은 도시 사이의 모든 최단 거리 즉 1~6까지 도시가 있으면 각 1번 도시부터 전체 도시로 가는 최단 거리를 구하는 알고리즘이다.
3중 반복문에서 
첫번째 반복문은 정점 1을 거쳐서 가는 거리와 거치지 않고 가는 거리를 비교 한다. 
2번째와 세 번째 반복문은 1번을 기점으로 시작해서 6번까지 각 정점에서 정점사이의 거리를 구한다.
반복문이 끝나면 각 1번 도시부터 전체 도시로 가는 최단 거리가 구해 진다.

하지만 3중 반복문이라서 O(n^3)으로 시간복잡도가 꽤 높은 편이다.

#include <string>
#include <vector>
#include <iostream>

using namespace std;
int memo[100];
int iCount;//최소 값 담는 곳

void DP(int N, int count)
{
	if (iCount != 0 && count > iCount) return;

	if (N == 1)
	{
		if (iCount == 0) iCount = count;
		if (iCount > count) iCount = count;//문어발 식으로 탑다운 하다가 최솟값보다 더 작은 값이 있으면 그 값을 최솟값에 넣어줌.
	}
	else
	{
		if (N % 3 == 0) DP(N/3, count+1);
		if (N % 2 == 0) DP(N/2, count+1);
		if (((N - 1) % 3 == 0) || ((N - 1) % 2 == 0)) DP(N - 1, count + 1);
		if (N>2 &&((N - 2) % 3 == 0) ) DP(N - 2, count + 2);
	}
}
int main(void)
{
  DP(572,0);
    cout << iCount;
}
백준에 똑같은 문제가 실버3난이도에 있어서 백준 것으로 풀었다.
처음에 쉬워보여서 생각나는대로 짰다가 고생했다.
이 문제에서 주의해야할 점들을 나열해보곘다.
1. 항상 3으로 나누는 것이 최적은 아니기에 모든 경우의 수로 다 연산을 해야한다. 그럼으로 else if 말고 각 각 의 if문으로 구성해야한다.
2. 1에서 파생되는 말이지만 그렇게 했다면 여러 depth가 생긴다. 그 중에서 가장 최솟값을 담아줘야 한다.
3. N이 2보다 작아질 경우도 고려해야한다.
